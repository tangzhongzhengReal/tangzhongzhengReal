<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="在虚拟节点的实现一篇中，除了知道了 VNode 类的实现之外，还简要地整理了一下 DOM 渲染的路径。在这一篇中，主要来分析一下两条路径的具体实现代码。 按照创建 Vue 实例后的一般执行流程，首先来看看实例初始化时对渲染模块的初始处理。这也是开始 mount 路径的前一步。初始包括两部分，一是向 Vue 类原型对象上挂载渲染相关的方法，而是初始化渲染相关的属性。 渲染的初始化相关属性的初始化12">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue 源码探究-虚拟 DOM 的渲染">
<meta property="og:url" content="http://yoursite.com/2019/04/09/vue-source-9/index.html">
<meta property="og:site_name" content="唐忠正">
<meta property="og:description" content="在虚拟节点的实现一篇中，除了知道了 VNode 类的实现之外，还简要地整理了一下 DOM 渲染的路径。在这一篇中，主要来分析一下两条路径的具体实现代码。 按照创建 Vue 实例后的一般执行流程，首先来看看实例初始化时对渲染模块的初始处理。这也是开始 mount 路径的前一步。初始包括两部分，一是向 Vue 类原型对象上挂载渲染相关的方法，而是初始化渲染相关的属性。 渲染的初始化相关属性的初始化12">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-04-08T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-05T15:57:16.160Z">
<meta property="article:author" content="唐忠正">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Vue 源码探究-虚拟 DOM 的渲染</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.1.1"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/tangzhongzhengReal">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/04/24/mplogin/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/04/02/vue-source-8/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/04/09/vue-source-9/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yoursite.com/2019/04/09/vue-source-9/&text=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/04/09/vue-source-9/&is_video=false&description=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Vue 源码探究-虚拟 DOM 的渲染&body=Check out this article: http://yoursite.com/2019/04/09/vue-source-9/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/04/09/vue-source-9/&name=Vue 源码探究-虚拟 DOM 的渲染&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">渲染的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">相关属性的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">挂载方法初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mount-%E8%B7%AF%E5%BE%84%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">mount 路径的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mountComponent"><span class="toc-number">2.1.</span> <span class="toc-text">mountComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updateComponent"><span class="toc-number">2.2.</span> <span class="toc-text">updateComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render"><span class="toc-number">2.3.</span> <span class="toc-text">_render</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update"><span class="toc-number">2.4.</span> <span class="toc-text">_update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch"><span class="toc-number">2.5.</span> <span class="toc-text">patch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createElm"><span class="toc-number">2.6.</span> <span class="toc-text">createElm</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Vue 源码探究-虚拟 DOM 的渲染
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">唐忠正</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-04-08T16:00:00.000Z" itemprop="datePublished">2019-04-09</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>在虚拟节点的实现一篇中，除了知道了 VNode 类的实现之外，还简要地整理了一下 DOM 渲染的路径。在这一篇中，主要来分析一下两条路径的具体实现代码。</p>
<p>按照创建 Vue 实例后的一般执行流程，首先来看看实例初始化时对渲染模块的初始处理。这也是开始 mount 路径的前一步。初始包括两部分，一是向 Vue 类原型对象上挂载渲染相关的方法，而是初始化渲染相关的属性。</p>
<h2 id="渲染的初始化"><a href="#渲染的初始化" class="headerlink" title="渲染的初始化"></a>渲染的初始化</h2><h3 id="相关属性的初始化"><a href="#相关属性的初始化" class="headerlink" title="相关属性的初始化"></a>相关属性的初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义并导出initRender函数，接受vm</span><br><span class="line">export function initRender (vm: Component) &#123;</span><br><span class="line">  &#x2F;&#x2F; 初始化实例的根虚拟节点</span><br><span class="line">  vm._vnode &#x3D; null &#x2F;&#x2F; the root of the child tree</span><br><span class="line">  &#x2F;&#x2F; 定义实例的静态树节点</span><br><span class="line">  vm._staticTrees &#x3D; null &#x2F;&#x2F; v-once cached trees</span><br><span class="line">  &#x2F;&#x2F; 获取配置对象</span><br><span class="line">  const options &#x3D; vm.$options</span><br><span class="line">  &#x2F;&#x2F; 设置父占位符节点</span><br><span class="line">  const parentVnode &#x3D; vm.$vnode &#x3D; options._parentVnode &#x2F;&#x2F; the placeholder node in parent tree</span><br><span class="line">  &#x2F;&#x2F; renderContext存储父节点有无声明上下文</span><br><span class="line">  const renderContext &#x3D; parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  &#x2F;&#x2F; 将子虚拟节点转换成格式化的对象结构存储在实例的$slots属性</span><br><span class="line">  vm.$slots &#x3D; resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">  &#x2F;&#x2F; 初始化$scopedSlots属性为空对象</span><br><span class="line">  vm.$scopedSlots &#x3D; emptyObject</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 为实例绑定渲染虚拟节点函数_c和$createElement</span><br><span class="line">  &#x2F;&#x2F; 内部实际调用createElement函数，并获得恰当的渲染上下文</span><br><span class="line">  &#x2F;&#x2F; 参数按顺序分别是：标签、数据、子节点、标准化类型、是否标准化标识</span><br><span class="line">  &#x2F;&#x2F; bind the createElement fn to this instance</span><br><span class="line">  &#x2F;&#x2F; so that we get proper render context inside it.</span><br><span class="line">  &#x2F;&#x2F; args order: tag, data, children, normalizationType, alwaysNormalize</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 内部版本_c被从模板编译的渲染函数使用</span><br><span class="line">  &#x2F;&#x2F; internal version is used by render functions compiled from templates</span><br><span class="line">  vm._c &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, false)</span><br><span class="line">  &#x2F;&#x2F; 用户写的渲染函数会总是应用执行标准化的公共版本</span><br><span class="line">  &#x2F;&#x2F; normalization is always applied for the public version, used in</span><br><span class="line">  &#x2F;&#x2F; user-written render functions.</span><br><span class="line">  vm.$createElement &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, true)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 为了更容易创建高阶组件，暴露了$attrs 和 $listeners</span><br><span class="line">  &#x2F;&#x2F; 并且需要保持属性的响应性以便能够实现更新，以下是对属性的响应处理</span><br><span class="line">  &#x2F;&#x2F; $attrs &amp; $listeners are exposed for easier HOC creation.</span><br><span class="line">  &#x2F;&#x2F; they need to be reactive so that HOCs using them are always updated</span><br><span class="line">  const parentData &#x3D; parentVnode &amp;&amp; parentVnode.data</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 对属性和事件监听器进行响应处理，建立观察状态</span><br><span class="line">  &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在非生产环境时检测是否属于可读并发出警告</span><br><span class="line">    defineReactive(vm, &#39;$attrs&#39;, parentData &amp;&amp; parentData.attrs || emptyObject, () &#x3D;&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(&#96;$attrs is readonly.&#96;, vm)</span><br><span class="line">    &#125;, true)</span><br><span class="line">    defineReactive(vm, &#39;$listeners&#39;, options._parentListeners || emptyObject, () &#x3D;&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(&#96;$listeners is readonly.&#96;,  vm)</span><br><span class="line">    &#125;, true)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    defineReactive(vm, &#39;$attrs&#39;, parentData &amp;&amp; parentData.attrs || emptyObject, null, true)</span><br><span class="line">    defineReactive(vm, &#39;$listeners&#39;, options._parentListeners || emptyObject, null, true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initRender 函数为实例进行了初始化处理，主要有三件事：</p>
<ul>
<li>初始化相关属性</li>
<li>设置绑定了上下文的生成虚拟节点的私有和共有版函数</li>
<li>对节点的属性和事件监听器进行状态观察</li>
</ul>
<p>生成虚拟节点函数主要会在流程中的 render 函数中使用。对节点属性和事件监听器的响应处理保证了在生命周期过程中节点属性和事件状态的更新。</p>
<h3 id="挂载方法初始化"><a href="#挂载方法初始化" class="headerlink" title="挂载方法初始化"></a>挂载方法初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导出renderMixin函数，接收形参Vue，</span><br><span class="line">&#x2F;&#x2F; 使用Flow进行静态类型检查指定为Component类</span><br><span class="line">export function renderMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  &#x2F;&#x2F; 为Vue原型对象绑定运行时相关的辅助方法</span><br><span class="line">  &#x2F;&#x2F; install runtime convenience helpers</span><br><span class="line">  installRenderHelpers(Vue.prototype)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 挂载Vue原型对象的$nextTick方法，接收函数类型的fn形参</span><br><span class="line">  Vue.prototype.$nextTick &#x3D; function (fn: Function) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回nextTick函数的执行结果</span><br><span class="line">    return nextTick(fn, this)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 挂载Vue原型对象的_render方法，期望返回虚拟节点对象</span><br><span class="line">  &#x2F;&#x2F; _render方法即是根据配置对象在内部生成虚拟节点的方法</span><br><span class="line">  Vue.prototype._render &#x3D; function (): VNode &#123;</span><br><span class="line">    &#x2F;&#x2F; 将实例赋值给vm变量</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    &#x2F;&#x2F; 导入vm的$options对象的render方法和_parentVnode对象</span><br><span class="line">    const &#123; render, _parentVnode &#125; &#x3D; vm.$options</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 非生产环境下重置插槽上的_rendered标志以进行重复插槽检查</span><br><span class="line">    &#x2F;&#x2F; reset _rendered flag on slots for duplicate slot check</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      for (const key in vm.$slots) &#123;</span><br><span class="line">        &#x2F;&#x2F; $flow-disable-line</span><br><span class="line">        vm.$slots[key]._rendered &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有父级虚拟节点，定义并赋值实例的$scopedSlots属性</span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots &#x3D; _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置实例的父虚拟节点，允许render函数访问占位符节点的数据</span><br><span class="line">    &#x2F;&#x2F; set parent vnode. this allows render functions to have access</span><br><span class="line">    &#x2F;&#x2F; to the data on the placeholder node.</span><br><span class="line">    vm.$vnode &#x3D; _parentVnode</span><br><span class="line">    &#x2F;&#x2F; 定义渲染节点</span><br><span class="line">    &#x2F;&#x2F; render self</span><br><span class="line">    let vnode</span><br><span class="line">    &#x2F;&#x2F; 在实例的渲染代理对象上调用render方法，并传入$createElement参数</span><br><span class="line">    try &#123;</span><br><span class="line">      vnode &#x3D; render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理错误</span><br><span class="line">      handleError(e, vm, &#96;render&#96;)</span><br><span class="line">      &#x2F;&#x2F; 返回错误渲染结果或者前一虚拟节点，防止渲染错误导致的空白组件</span><br><span class="line">      &#x2F;&#x2F; return error render result,</span><br><span class="line">      &#x2F;&#x2F; or previous vnode to prevent render error causing blank component</span><br><span class="line">      &#x2F;&#x2F; 非生产环境特殊处理渲染错误</span><br><span class="line">      &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">        if (vm.$options.renderError) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            vnode &#x3D; vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, vm, &#96;renderError&#96;)</span><br><span class="line">            vnode &#x3D; vm._vnode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          vnode &#x3D; vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode &#x3D; vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 在渲染函数出错时返回空虚拟节点</span><br><span class="line">    &#x2F;&#x2F; return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 非生产环境报错</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Multiple root nodes returned from render function. Render function &#39; +</span><br><span class="line">          &#39;should return a single root node.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 创建空的虚拟节点</span><br><span class="line">      vnode &#x3D; createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置父虚拟节点</span><br><span class="line">    &#x2F;&#x2F; set parent</span><br><span class="line">    vnode.parent &#x3D; _parentVnode</span><br><span class="line">    &#x2F;&#x2F; 返回虚拟节点</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>渲染模块挂载了两个方法 $nextTick 公共方法和 _render 私有方法$nextTick 是实例的公有方法，这个很常见，就不多说；_render 是内部用来生成 VNode 的方法，内部调用了 initRender 函数中绑定的 createElement 函数，初始化实例一般会调用实例的公共版方法，如果是创建组件则会调用私有版方法。</p>
<p>另 renderMixin 函数在执行时还为 Vue 实例绑定了一些处理渲染的工具函数，具体可查看源代码。</p>
<h2 id="mount-路径的具体实现"><a href="#mount-路径的具体实现" class="headerlink" title="mount 路径的具体实现"></a>mount 路径的具体实现</h2><p>按照创建 Vue 实例的一般流程，初始化处理好之后，最后一步执行的 vm.$mount(vm.$options.el) 就宣告 mount 渲染路径的开始。记得好像还没有见过 $mount 的定义，因为这个函数是在运行时挂在到原型对象上的，web 端的源代码在 platforms/web 中，同样要值得注意的是原型的 <strong>patch</strong> 方法也是在运行时定义的。代码片段如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; install platform patch function</span><br><span class="line">Vue.prototype.__patch__ &#x3D; inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; public mount method</span><br><span class="line">Vue.prototype.$mount &#x3D; function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这两个方法都是在运行时才定义，但各自都是引用了核心代码中定义的实际实现函数：mountComponent 和 patch，下面就按照执行的流程一步步来解析这些实现渲染功能的函数。</p>
<h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义并导出mountComponent函数</span><br><span class="line">&#x2F;&#x2F; 接受Vue实例vm，DOM元素el、布尔标识hydrating参数</span><br><span class="line">&#x2F;&#x2F; 后两参数可选，返回组件实例</span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  &#x2F;&#x2F; 设置实例的$el属性</span><br><span class="line">  vm.$el &#x3D; el</span><br><span class="line">  &#x2F;&#x2F; 检测实例属性$options对象的render方法，未定义则设置为创建空节点</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render &#x3D; createEmptyVNode</span><br><span class="line">    &#x2F;&#x2F; 非生产环境检测构建版本并警告</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !&#x3D;&#x3D; &#39;#&#39;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;You are using the runtime-only build of Vue where the template &#39; +</span><br><span class="line">          &#39;compiler is not available. Either pre-compile the templates into &#39; +</span><br><span class="line">          &#39;render functions, or use the compiler-included build.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Failed to mount component: template or render function not defined.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 调用生命周期钩子函数beforeMount，准备首次加载</span><br><span class="line">  callHook(vm, &#39;beforeMount&#39;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 定义updateComponent方法</span><br><span class="line">  let updateComponent</span><br><span class="line">  &#x2F;&#x2F; 非生产环境加入性能评估</span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      const name &#x3D; vm._name</span><br><span class="line">      const id &#x3D; vm._uid</span><br><span class="line">      const startTag &#x3D; &#96;vue-perf-start:$&#123;id&#125;&#96;</span><br><span class="line">      const endTag &#x3D; &#96;vue-perf-end:$&#123;id&#125;&#96;</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode &#x3D; vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; render&#96;, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; patch&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义updateComponent内部调用实例的_update方法</span><br><span class="line">    &#x2F;&#x2F; 参数为按实例状态生成的新虚拟节点树和hydrating标识</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在Watcher类内部将此监听器设置到实例的_watcher上。</span><br><span class="line">  &#x2F;&#x2F; 由于初次patch可能调用$forceUpdate方法（例如在子组件的mounted钩子），</span><br><span class="line">  &#x2F;&#x2F; 这依赖于已经定义好的vm._watcher</span><br><span class="line">  &#x2F;&#x2F; we set this to vm._watcher inside the watcher&#39;s constructor</span><br><span class="line">  &#x2F;&#x2F; since the watcher&#39;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  &#x2F;&#x2F; component&#39;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line">  &#x2F;&#x2F; 建立对渲染的观察，最末参数声明为渲染监听器，并传入监视器的before方法，</span><br><span class="line">  &#x2F;&#x2F; 在初次渲染之后，实例的_isMounted为true，在每次渲染更新之前会调用update钩子</span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#39;beforeUpdate&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true &#x2F;* isRenderWatcher *&#x2F;)</span><br><span class="line">  &#x2F;&#x2F; 设置hydrating标识为false</span><br><span class="line">  hydrating &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 手动安装的实例，mounted调用挂载在自身</span><br><span class="line">  &#x2F;&#x2F; 渲染创建的子组件在其插入的钩子中调用了mounted</span><br><span class="line">  &#x2F;&#x2F; manually mounted instance, call mounted on self</span><br><span class="line">  &#x2F;&#x2F; mounted is called for render-created child components in its inserted hook</span><br><span class="line">  &#x2F;&#x2F; vm.$vnode为空设置_isMounted属性为true，并调用mounted钩子</span><br><span class="line">  &#x2F;&#x2F; vm.$vnode为空是因为实例是根组件，没有父级节点。</span><br><span class="line">  if (vm.$vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    vm._isMounted &#x3D; true</span><br><span class="line">    callHook(vm, &#39;mounted&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回实例</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h3><p>updateComponent 函数在上一流程中定义，在执行过程中传入为待观察属性创建的监视器中，并在首次渲染时被调用。可以在上述代码中看出，其内部是执行了实例的 _update 方法，并传入实例 _render 方法的执行结果和 hydrating 参数，hydrating 似乎是与服务器端渲染有关的标识属性，暂时不太清楚具体的作用。</p>
<h3 id="render"><a href="#render" class="headerlink" title="_render"></a>_render</h3><p>在文首的 renderMixin 函数中定义，返回虚拟节点作为传入下一流程 _update 的第一个参数。</p>
<h3 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h3><p>在前文生命周期中的 lifecycleMixin 函数中定义，正是在这个方法中，发生了执行路径的分流，在 mount 路径中，执行首次渲染分支，将挂载的 DOM 元素和 _render 首次生成的虚拟节点传入 patch 函数中。</p>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>patch 方法定义在 platforms/web/runtime/patch.js 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const patch: Function &#x3D; createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>

<p>从最后一句代码可以看出，patch 得到的是 createPatchFunction 执行后内部返回的 patch 函数，传入的是平台特有的参数。在 createPatchFunction 函数执行过程中定义了一系列闭包函数来实现最终的 DOM 渲染，具体代码非常多，简单解释一下其内部定义的各种函数的用途，最后详细探索一下 patch 函数的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义并导出createPatchFunction函数，接受backend参数</span><br><span class="line">&#x2F;&#x2F; backend参数是一个含有平台相关BOM操作的对象方法集</span><br><span class="line">export function createPatchFunction (backend) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建空虚拟节点函数</span><br><span class="line">  function emptyNodeAt (elm) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建移除DOM节点回调</span><br><span class="line">  function createRmCb (childElm, listeners) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 移除DOM节点</span><br><span class="line">  function removeNode (el) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 判断是否是未知元素</span><br><span class="line">  function isUnknownElement (vnode, inVPre) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建并插入DOM元素</span><br><span class="line">  function createElm (</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    parentElm,</span><br><span class="line">    refElm,</span><br><span class="line">    nested,</span><br><span class="line">    ownerArray,</span><br><span class="line">    index</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化组件</span><br><span class="line">  function initComponent (vnode, insertedVnodeQueue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 激活组件</span><br><span class="line">  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 插入DOM节点</span><br><span class="line">  function insert (parent, elm, ref) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建子DOM节点</span><br><span class="line">  function createChildren (vnode, children, insertedVnodeQueue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 判断节点是否可对比更新</span><br><span class="line">  function isPatchable (vnode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 调用创建钩子</span><br><span class="line">  function invokeCreateHooks (vnode, insertedVnodeQueue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 为组件作用域CSS设置范围id属性。</span><br><span class="line">  &#x2F;&#x2F; 这是作为一种特殊情况实现的，以避免通过正常的属性修补过程的开销。</span><br><span class="line">  &#x2F;&#x2F; set scope id attribute for scoped CSS.</span><br><span class="line">  &#x2F;&#x2F; this is implemented as a special case to avoid the overhead</span><br><span class="line">  &#x2F;&#x2F; of going through the normal attribute patching process.</span><br><span class="line">  &#x2F;&#x2F; 设置CSS作用域ID</span><br><span class="line">  function setScope (vnode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 添加虚拟节点，内部调用createElm</span><br><span class="line">  function addVnodes () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 调用销毁钩子</span><br><span class="line">  function invokeDestroyHook (vnode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 移除虚拟节点，内部调用removeNode或removeAndInvokeRemoveHook</span><br><span class="line">  function removeVnodes (parentElm, vnodes, startIdx, endIdx) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 调用移除事件回调函数并移除节点</span><br><span class="line">  function removeAndInvokeRemoveHook (vnode, rm) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 更新子节点</span><br><span class="line">  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 检查重复key</span><br><span class="line">  function checkDuplicateKeys (children) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 寻找旧子节点索引</span><br><span class="line">  function findIdxInOld (node, oldCh, start, end) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 对比并更新虚拟节点</span><br><span class="line">  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 调用插入钩子</span><br><span class="line">  function invokeInsertHook (vnode, queue, initial) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 渲染混合</span><br><span class="line">  &#x2F;&#x2F; 注意：这是一个仅限浏览器的函数，因此我们可以假设elms是DOM节点。</span><br><span class="line">  &#x2F;&#x2F; Note: this is a browser-only function so we can assume elms are DOM nodes.</span><br><span class="line">  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 判断节点匹配</span><br><span class="line">  function assertNodeMatch (node, vnode, inVPre) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 节点补丁函数</span><br><span class="line">  &#x2F;&#x2F; 接受旧新虚拟节点，hydrating和removeOnly标识</span><br><span class="line">  return function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果新虚拟节点未定义且存在旧节点，则调用销毁节点操作并返回</span><br><span class="line">    &#x2F;&#x2F; 这一步的判断是因为在旧虚拟节点存时，变动后没有生成新虚拟节点</span><br><span class="line">    &#x2F;&#x2F; 则说明新结构是不存在的，所以要清空旧节点。</span><br><span class="line">    if (isUndef(vnode)) &#123;</span><br><span class="line">      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化isInitialPatch标识和insertedVnodeQueue队列</span><br><span class="line">    let isInitialPatch &#x3D; false</span><br><span class="line">    const insertedVnodeQueue &#x3D; []</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下分两种情况构建节点：</span><br><span class="line">    &#x2F;&#x2F; 如果不存在旧虚拟节点</span><br><span class="line">    if (isUndef(oldVnode)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 空挂载（比如组件），会创建新的根元素</span><br><span class="line">      &#x2F;&#x2F; empty mount (likely as component), create new root element</span><br><span class="line">      &#x2F;&#x2F; 这种情况说明时首次渲染，设置isInitialPatch为true</span><br><span class="line">      isInitialPatch &#x3D; true</span><br><span class="line">      &#x2F;&#x2F; 根据虚拟节点创建新DOM节点</span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 存在旧虚拟节点</span><br><span class="line">      &#x2F;&#x2F; 判断旧虚拟节点是否是真实的DOM元素</span><br><span class="line">      const isRealElement &#x3D; isDef(oldVnode.nodeType)</span><br><span class="line">      &#x2F;&#x2F; 如果不是真实DOM节点并且新旧虚拟节点根节点相同</span><br><span class="line">      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行比较新旧节点更新DOM操作</span><br><span class="line">        &#x2F;&#x2F; patch existing root node</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 新旧节点不相同的情况</span><br><span class="line">        &#x2F;&#x2F; 旧节点是DOM元素时先将旧节点转换成虚拟节点</span><br><span class="line">        if (isRealElement) &#123;</span><br><span class="line">          &#x2F;&#x2F; 挂在到真实DOM元素</span><br><span class="line">          &#x2F;&#x2F; 检查是否是服务器渲染，然后执行合并操作</span><br><span class="line">          &#x2F;&#x2F; mounting to a real element</span><br><span class="line">          &#x2F;&#x2F; check if this is server-rendered content and if we can perform</span><br><span class="line">          &#x2F;&#x2F; a successful hydration.</span><br><span class="line">          &#x2F;&#x2F; 下面这两个if语句里的操作都是服务器渲染相关，暂不去了解</span><br><span class="line">          if (oldVnode.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating &#x3D; true</span><br><span class="line">          &#125;</span><br><span class="line">          if (isTrue(hydrating)) &#123;</span><br><span class="line">            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, true)</span><br><span class="line">              return oldVnode</span><br><span class="line">            &#125; else if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                &#39;The client-side rendered virtual DOM tree is not matching &#39; +</span><br><span class="line">                &#39;server-rendered content. This is likely caused by incorrect &#39; +</span><br><span class="line">                &#39;HTML markup, for example nesting block-level elements inside &#39; +</span><br><span class="line">                &#39;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#39; +</span><br><span class="line">                &#39;full client-side render.&#39;</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 如果不是服务器渲染或合并失败，生成空的虚拟节点</span><br><span class="line">          &#x2F;&#x2F; either not server-rendered, or hydration failed.</span><br><span class="line">          &#x2F;&#x2F; create an empty node and replace it</span><br><span class="line">          oldVnode &#x3D; emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 定义旧元素oldElm和其父元素</span><br><span class="line">        &#x2F;&#x2F; replacing existing element</span><br><span class="line">        const oldElm &#x3D; oldVnode.elm</span><br><span class="line">        const parentElm &#x3D; nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 根据新虚拟节点创建新DOM元素，并且会插入到DOM树中</span><br><span class="line">        &#x2F;&#x2F; create new node</span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          &#x2F;&#x2F; 以下参数是#4590问题的解决处理</span><br><span class="line">          &#x2F;&#x2F; extremely rare edge case: do not insert if old element is in a</span><br><span class="line">          &#x2F;&#x2F; leaving transition. Only happens when combining transition +</span><br><span class="line">          &#x2F;&#x2F; keep-alive + HOCs. (#4590)</span><br><span class="line">          oldElm._leaveCb ? null : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果新的虚拟节点有父级则以递归方式更新父占位符节点元素</span><br><span class="line">        &#x2F;&#x2F; cbs是在生成patch函数时初始化好的事件监听器</span><br><span class="line">        &#x2F;&#x2F; 在此条件中也会被逐一触发</span><br><span class="line">        &#x2F;&#x2F; update parent placeholder node element, recursively</span><br><span class="line">        if (isDef(vnode.parent)) &#123;</span><br><span class="line">          let ancestor &#x3D; vnode.parent</span><br><span class="line">          const patchable &#x3D; isPatchable(vnode)</span><br><span class="line">          while (ancestor) &#123;</span><br><span class="line">            for (let i &#x3D; 0; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm &#x3D; vnode.elm</span><br><span class="line">            if (patchable) &#123;</span><br><span class="line">              for (let i &#x3D; 0; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              &#x2F;&#x2F; #6513</span><br><span class="line">              &#x2F;&#x2F; invoke insert hooks that may have been merged by create hooks.</span><br><span class="line">              &#x2F;&#x2F; e.g. for directives that uses the &quot;inserted&quot; hook.</span><br><span class="line">              const insert &#x3D; ancestor.data.hook.insert</span><br><span class="line">              if (insert.merged) &#123;</span><br><span class="line">                &#x2F;&#x2F; start at index 1 to avoid re-invoking component mounted hook</span><br><span class="line">                for (let i &#x3D; 1; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor &#x3D; ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 销毁旧节点</span><br><span class="line">        &#x2F;&#x2F; destroy old node</span><br><span class="line">        &#x2F;&#x2F; 如果旧节点的父级元素存在，则从其上移除旧节点</span><br><span class="line">        if (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], 0, 0)</span><br><span class="line">        &#125; else if (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          &#x2F;&#x2F; 否则视为不存在旧DOM节点，此时如果虚拟节点有标签名</span><br><span class="line">          &#x2F;&#x2F; 则调用旧虚拟节点销毁钩子</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最后调用新节点的插入钩子</span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    &#x2F;&#x2F; 返回虚拟节点的真实DOM元素</span><br><span class="line">    return vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>createPatchFunction 函数内容非常多，但大多数函数都是辅助性的，与节点处理和回调函数钩子相关。大致上了解作用即可。<br>patch 方法的执行首先分了两条路线：</p>
<ul>
<li>不存在旧虚拟节点直接创建新节点插入到 DOM 树，这是首次渲染的执行路径，这种情况简单。</li>
<li>存在旧虚拟节点时需进行对比再更新，这种情况比较复杂，其中又要分旧节点是否是真实 DOM 的情况，是虚拟节点并且与新生成虚拟节点相等（这里的相等是指同样的虚拟根节点，具体可参照 sameVnode 的代码查看条件）则直接进行对比更新；若是真实节点要先进行到虚拟节点的转换还有与服务器渲染相关的判断，然后再根据得到的结果创建新的 DOM 节点插入页面，最后还要分情况进行父节点的递归更新和移除旧节点。</li>
</ul>
<p>patch 方法的实现方式是有迹可循的，在这源代码中，可以看出之前划分的 mount 和 update 的执行流程，但要注意的是，上述的条件判断划分的路线和逻辑上划分的流程是稍有区别的，mount 路径其实在代码里体现为 !oldVnode 和 oldVnode 路线中是真实 DOM 元素的情况，跨越了两个条件，主要体现在直接调用了 createElm 创建并插入新节点，这是因为在渲染时分为有无声明挂载的真实 DOM 元素两种情况。而 update 直接进入的是 patchVnode 对比操作。虽然有点绕但是需要分清楚这种区别。然而具体如何实现节点的创建和对比更新还是得继续往里层看，由于这一条路径是讲 mount 情况，所以往下先看看与之接续的 createElm 函数。</p>
<h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a>createElm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义createElm函数，一系列参数主要记住vnode，parentElm</span><br><span class="line">function createElm (</span><br><span class="line">  vnode,</span><br><span class="line">  insertedVnodeQueue,</span><br><span class="line">  parentElm,</span><br><span class="line">  refElm,</span><br><span class="line">  nested,</span><br><span class="line">  ownerArray,</span><br><span class="line">  index</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果新虚拟节点存在真实DOM元素和ownerArray，</span><br><span class="line">  &#x2F;&#x2F; 则代表它在之前的渲染中用过。</span><br><span class="line">  &#x2F;&#x2F; 现在要被用作新节点时有潜在的错误</span><br><span class="line">  &#x2F;&#x2F; 所以将它改为从本身克隆的节点</span><br><span class="line">  if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    &#x2F;&#x2F; This vnode was used in a previous render!</span><br><span class="line">    &#x2F;&#x2F; now it&#39;s used as a new node, overwriting its elm would cause</span><br><span class="line">    &#x2F;&#x2F; potential patch errors down the road when it&#39;s used as an insertion</span><br><span class="line">    &#x2F;&#x2F; reference node. Instead, we clone the node on-demand before creating</span><br><span class="line">    &#x2F;&#x2F; associated DOM element for it.</span><br><span class="line">    vnode &#x3D; ownerArray[index] &#x3D; cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置isRootInsert，为检查过度动画入口</span><br><span class="line">  vnode.isRootInsert &#x3D; !nested &#x2F;&#x2F; for transition enter check</span><br><span class="line">  &#x2F;&#x2F; 下面判断用于keep-alive组件，若是普通组件则会返回undefined继续往下执行</span><br><span class="line">  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 获取虚拟节点信息、子节点和标签名称</span><br><span class="line">  const data &#x3D; vnode.data</span><br><span class="line">  const children &#x3D; vnode.children</span><br><span class="line">  const tag &#x3D; vnode.tag</span><br><span class="line">  &#x2F;&#x2F; 下面三种情况创建普通节点、注释节点和文字节点</span><br><span class="line">  if (isDef(tag)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 具有标签名称，则创建普通节点</span><br><span class="line">    &#x2F;&#x2F; 非生产环境简则是否是正确的元素</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      if (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      if (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Unknown custom element: &lt;&#39; + tag + &#39;&gt; - did you &#39; +</span><br><span class="line">          &#39;register the component correctly? For recursive components, &#39; +</span><br><span class="line">          &#39;make sure to provide the &quot;name&quot; option.&#39;,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据ns属性选择创建节点的方式创建节点</span><br><span class="line">    vnode.elm &#x3D; vnode.ns</span><br><span class="line">      ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">    &#x2F;&#x2F; 设置节点的作用域ID</span><br><span class="line">    setScope(vnode)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果是weex平台，可以根据参数调整节点树插入DOM的具体实现</span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (__WEEX__) &#123;</span><br><span class="line">      &#x2F;&#x2F; in Weex, the default insertion order is parent-first.</span><br><span class="line">      &#x2F;&#x2F; List items can be optimized to use children-first insertion</span><br><span class="line">      &#x2F;&#x2F; with append&#x3D;&quot;tree&quot;.</span><br><span class="line">      const appendAsTree &#x3D; isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">      if (!appendAsTree) &#123;</span><br><span class="line">        if (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      if (appendAsTree) &#123;</span><br><span class="line">        if (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; web平台则先创建子节点插入父级后再一次插入DOM中</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      if (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      creatingElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是注释节点，则创建注释节点并插入到DOM中</span><br><span class="line">    vnode.elm &#x3D; nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是文字节点，则创建文字节点并插入到DOM</span><br><span class="line">    vnode.elm &#x3D; nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>createElm 函数包含了节点的创建和插入两部分，创建了虚拟节点对应的 DOM 元素之后，就会调用 insert 方法将它插入到页面 DOM 结构中。创建功能在这里遵循 DOM 的三种节点类型，即元素、注释和文字节点，实际与插入和移除方法一样都是使用了对应的原生方法 ，nodeops 对象即是在返回 patch 函数时预先导入了的原生 DOM 操作方法的集合，具体可以在运行时的处理中确认。之前生成的 vnode 决定了最终应该生成何种节点，在这个函数中就能够发现，最终生成的真实 DOM 节点是多么依赖于 vnode 所携带的信息，所以说虚拟节点是实现生成真实 DOM 的基础。</p>
<p>这个流程中最后一步再调用 removeVnodes 方法移除掉 DOM 树中的旧节点，到此为止 mount 路径的执行就结束了。</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/tangzhongzhengReal">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">渲染的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">相关属性的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">挂载方法初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mount-%E8%B7%AF%E5%BE%84%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">mount 路径的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mountComponent"><span class="toc-number">2.1.</span> <span class="toc-text">mountComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updateComponent"><span class="toc-number">2.2.</span> <span class="toc-text">updateComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render"><span class="toc-number">2.3.</span> <span class="toc-text">_render</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update"><span class="toc-number">2.4.</span> <span class="toc-text">_update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch"><span class="toc-number">2.5.</span> <span class="toc-text">patch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createElm"><span class="toc-number">2.6.</span> <span class="toc-text">createElm</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/04/09/vue-source-9/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yoursite.com/2019/04/09/vue-source-9/&text=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/04/09/vue-source-9/&is_video=false&description=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Vue 源码探究-虚拟 DOM 的渲染&body=Check out this article: http://yoursite.com/2019/04/09/vue-source-9/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yoursite.com/2019/04/09/vue-source-9/&title=Vue 源码探究-虚拟 DOM 的渲染"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/04/09/vue-source-9/&name=Vue 源码探究-虚拟 DOM 的渲染&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 唐忠正
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/tangzhongzhengReal">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>



    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



